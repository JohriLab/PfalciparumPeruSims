//This script simulates a p falcipaurm population in Peru over a few generations.
//Note that we are modeling a haploid population
//mutation rate is 0.
//Population sizes are determined using the Maynas annual incidence rates 

initialize() {
	initializeChromosome(1, 2, type="H"); //haploid chromosome of length 2
	initializeMutationRate(0);
	initializeMutationType("m1", 1.0, "f", d_f_sel_hrp2); //htp2 deletion -- neutral
	initializeMutationType("m2", 1.0, "f", d_f_sel_hrp3); //hrp3 deletion -- neutral
	initializeGenomicElementType("g1", c(m1,m2), c(1.0, 1.0));
	m1.convertToSubstitution==F;
	m2.convertToSubstitution==F;
	initializeGenomicElement(g1); //2 sites
	initializeRecombinationRate(0.5); //Note that this only applies when not clonal, i.e., 5% of the time
	writeFile(d_folder + "/haplotype_frequencies/output" + d_repID + ".csv",
		"generation,sample,hrp2_only,hrp3_only,double_deletion,wildtype", append=F);
}
//Can delete this, but I wanted to write a function as a sanity check to look at starting mutation frequencies and log them over time so we can also compare to vcf/other calculations to verify 
function (void)HaplotypeFrequencies(object inds, integer total) {
	//counter of each lineage to track mutation type
	hrp2_only = 0;
	hrp3_only = 0;
	double_deletion = 0;
	wildtype = 0;
	
	for (ind in inds) {
		hasHrp2 = ind.containsMarkerMutation(m1, 0); //check if individual has hrp2 in position 0
		hasHrp3 = ind.containsMarkerMutation(m2, 1); //check if individual has hrp3 in position 1
		
		if (hasHrp2 & hasHrp3) { //if individual has both hrp2 and hrp3, then it is a double deletion
			double_deletion = double_deletion + 1;
		} else if (hasHrp2 & !hasHrp3) { //if indiviudal has only hrp2
			hrp2_only = hrp2_only + 1;
		} else if (hasHrp3 & !hasHrp2) { //if individual has only hrp3
			hrp3_only = hrp3_only + 1;
		} else if (!hasHrp2 & !hasHrp3) { //if individual has neither, then wildtype
			wildtype = wildtype + 1;
		}
	}
	
	//make log file of frequencies
	line = sim.cycle + "," + total + "," + (hrp2_only/total) + "," + (hrp3_only/total) + "," + (double_deletion/total) + "," + (wildtype/total);
	writeFile(d_folder + "/haplotype_frequencies/output" + d_repID + ".csv", line, append=T);
}


// ancestral population (average 2003-2004)
1 early()    { sim.addSubpop("p1", asInteger(340)); //creating population
	sim.addSubpop("p2", asInteger(2)); //create dummy subpopulation so mutations don't fix internally in Slim
	p1.setCloningRate(0.95);//correspond to Fws=0.95
}

1 late () {
	/// STEP 1: Subset population into four groups by frequency
	freqs = c(0.140896402, 0.220766129, 0.119804591, 0.518532878);  // frequencies averaged 2003-2004(double deletion, wildtype, hrp2, hrp3)
	
	inds = p1.haplosomes; //define by individual haploid genomes instead of diploid genomes
	total = p1.individualCount; //number of haploid individuals
	
	groupSizes = asInteger(round(total * freqs)); //number of individuals in each group
	
	groupNames = c("double_deletion", "wildtype", "hrp2", "hrp3"); //define lineages
	
	// Create dictionary for groups to add individuals based on calculated sizes
	groups = Dictionary();
	
	start = 0;
	for (i in seqAlong(groupSizes)) { //iterate through group sizes
		end = start + groupSizes[i]; //size of group
		groups.setValue(groupNames[i], inds[(start):(end-1)]); //haploid genomes in index of groupsize have that lineage ID in dictionary
		start = end;
	}
	
	// STEP 2: Add mutations (made double deletion mutation the same as hrp2 and hrp3 mutations for simplicity)
	vals_hrp2 = groups.getValue("hrp2"); //define individuals in hrp2 only 
	vals_hrp3 = groups.getValue("hrp3"); //define individuals in hrp3 only
	vals_dd   = groups.getValue("double_deletion"); //define individuals in double deletion group
	
	// create hrp2 mutation and add to hrp2 + double_deletion
	mut_hrp2 = vals_hrp2[0].addNewDrawnMutation(m1, 0); //draw mutation on first individual
	vals_hrp2.addMutations(mut_hrp2); //add mutation to hrp2 group
	vals_dd.addMutations(mut_hrp2); //add mutation to double deletion group -- added these together because we want them to have the same mutation, otherwise it will show up as different m1 mutations in the vcf
	
	// create hrp3 mutation and add to hrp3 + double_deletion
	mut_hrp3 = vals_hrp3[0].addNewDrawnMutation(m2, 1);
	vals_hrp3.addMutations(mut_hrp3); // add mutation to hrp3 group
	vals_dd.addMutations(mut_hrp3); //add mutation to double deletion group -- added these together because we want them to have the same mutation, otherwise it will show up as different m2 mutations in the vcf
	
	//STEP 3 (OPTIONAL): The mutations were added in order, if you are adding recombination (at some point), you may want to shuffle the individuals so they're not reproducing only with individuals next to them that have same mutation type
	sample(p1.individuals, p1.individualCount);
	
	
	//DEBUGGING: print group names, count, and frequency in population
	for (name in groupNames) {
		vals = groups.getValue(name);
		nInds = vals.size();
		prop = nInds / total;
		catn(name + " | count: " + nInds + " | proportion: " + prop);
	}
	//another sanity check: calculate genotype frequencies directly with MutationFrequencies function
	//MutationFrequencies(inds, total);

}

//2003-2004
1 late() {inds = sample(p1.haplosomes, 176);
	total = 176;
	HaplotypeFrequencies(inds, total);}

//2005
10 early() { p1.setSubpopulationSize(asInteger(721)); } // 2005
10 late()  {inds = sample(p1.haplosomes, 168);
	total = 168;
	HaplotypeFrequencies(inds, total);}

//2006
19 early() { p1.setSubpopulationSize(asInteger(511)); }     // 2006
19 late() {inds = sample(p1.haplosomes, 10);
	total = 10;
	HaplotypeFrequencies(inds, total);}

//2007  
28 early()   { p1.setSubpopulationSize(asInteger(400)); }     // 2007
28 late() {inds = sample(p1.haplosomes, 8);
	total = 8;
	HaplotypeFrequencies(inds, total);}

//2008  
37 early()   { p1.setSubpopulationSize(asInteger(207)); }     // 2008
37 late() {inds = sample(p1.haplosomes, 31);
	total = 31;
	HaplotypeFrequencies(inds, total);}

//2009  
46 early()   { p1.setSubpopulationSize(asInteger(139)); }     // 2009
46 late() {inds = sample(p1.haplosomes, 50);
	total = 50;
	HaplotypeFrequencies(inds, total);}

//2010
55 early()   { p1.setSubpopulationSize(asInteger(109)); }     // 2010
55 late() {inds = sample(p1.haplosomes, 69);
	total = 69;
	HaplotypeFrequencies(inds, total);}

//2011  
64 early()   { p1.setSubpopulationSize(asInteger(213)); }     // 2011
64 late() {inds = sample(p1.haplosomes, 14);
	total = 14;
	HaplotypeFrequencies(inds, total);} 

//2012
73 early()   { p1.setSubpopulationSize(asInteger(259)); }     // 2012
73 late() {inds = sample(p1.haplosomes, 29);
	total = 29;
	HaplotypeFrequencies(inds, total);} 

//2013 
82 early()   { p1.setSubpopulationSize(asInteger(329)); }     // 2013
82 late () {inds = sample(p1.haplosomes, 33);
	total = 33;
	HaplotypeFrequencies(inds, total);}

//2014  
91 early()   { p1.setSubpopulationSize(asInteger(335)); }     // 2014
91 late () {inds = sample(p1.haplosomes, 27);
	total = 27;
	HaplotypeFrequencies(inds, total);}

//2015   
100 early()  { p1.setSubpopulationSize(asInteger(368)); }     // 2015
100 late () {inds = sample(p1.haplosomes, 202);
	total = 202;
	HaplotypeFrequencies(inds, total);}

//2016  
109 early()  { p1.setSubpopulationSize(asInteger(495)); }    // 2016
109 late() {inds = sample(p1.haplosomes, 104);
	total = 104;
	HaplotypeFrequencies(inds, total);}

//2017  
118 early()  { p1.setSubpopulationSize(asInteger(350)); }     // 2017
118 late() {inds = sample(p1.haplosomes, 79);
	total = 79;
	HaplotypeFrequencies(inds, total);}

//2018  
127 early()  { p1.setSubpopulationSize(asInteger(346)); }     // 2018
127 late() {inds = sample(p1.haplosomes, 38);
	total = 38;
	HaplotypeFrequencies(inds, total);}  

// Stop at end of 2018 (135 = 15 Ã— 9 generations)
135 late() {
	//output final frequencies
	inds = sample(p1.haplosomes, 38); //define by individual haploid genomes 
	total = 38; //number of haploid individuals
	HaplotypeFrequencies(inds, total);
	//p1.outputHaplosomes(d_folder + d_repID);
	//Sample output: VCF and MS file
	//g = sample(p1.haplosomes, 38); //38 in 2018 
	//g.outputHaplosomesToMS(d_folder + "/sample2018/output" + d_repID + ".ms");//check this line for haplosomes
	//g.outputHaplosomesToVCF(d_folder + "/sample2018/output" + d_repID + ".vcf");
	sim.simulationFinished();
}
